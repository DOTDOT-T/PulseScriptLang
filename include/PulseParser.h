/**
 * @file PulseParser.h
 * @author
 *     Dorian LEXTERIAQUE (dlexteriaque@gmail.com)
 *
 * @brief
 *     High-level syntactic analyzer for the PulseScript language.
 *
 *     The parser consumes the token stream generated by the lexer and produces
 *     a fully structured Abstract Syntax Tree (AST). This AST is later used
 *     by the PulseScript interpreter.
 *
 *     The parser implements:
 *       - Statement parsing (let, function, calls)
 *       - Expression parsing with precedence rules
 *       - Function definitions and scoped blocks
 *       - Strict error reporting with contextual diagnostics
 *
 *     PulseScript is designed as a lightweight, high-level scripting layer
 *     dedicated to gameplay logic inside the Pulse Engine. The parser enforces
 *     syntactic integrity and guarantees a clean AST layout optimized for
 *     real-time evaluation.
 *
 * @version 0.2
 * @date 2025-11-20
 *
 * @copyright
 *     Copyright (c) 2025 â€” Pulse Engine
 *     All rights reserved.
 * 
 */

#pragma once
#include "PulseLexer.h"
#include <vector>
#include <string>
#include <memory>
#include <functional>
#include <stdexcept>
#include "utilities.h"

// AST NODES

struct ASTNumber : ASTExpression
{
    int value;
    ASTNumber(int v) : value(v) {}
    Value Evaluate(Scope& scope) const override
    {
        return value;
    }
};
struct ASTFloatingNumber : ASTExpression
{
    float value;
    ASTFloatingNumber(float v) : value(v) {}
    Value Evaluate(Scope& scope) const override
    {
        return value;
    }
};

struct ASTString : ASTExpression
{
    std::string value;
    ASTString(const std::string &v) : value(v) {}
    Value Evaluate(Scope& scope) const override
    {
        return value;
    }
};

struct ASTIdentifier : ASTExpression
{
    std::string name;
    ASTIdentifier(const std::string &n) : name(n) {}
    Value Evaluate(Scope& scope) const override
    {
        Variable* it = scope.Find(name);
        if (it)
            return it->value;
        throw std::runtime_error("Undefined variable: " + name);
    }
};

struct ASTFunctionCall : ASTExpression
{
    std::string name;
    std::vector<std::unique_ptr<ASTExpression>> args;
    Value Evaluate(Scope& scope) const override
    {
        throw std::runtime_error("To implemente ASTFunctionCall");
    }
};

struct ASTBinaryOp : ASTExpression
{
    char op; // '+', '-', '*', '/'
    std::unique_ptr<ASTExpression> left;
    std::unique_ptr<ASTExpression> right;

    ASTBinaryOp(char op,
                std::unique_ptr<ASTExpression> left,
                std::unique_ptr<ASTExpression> right)
        : op(op), left(std::move(left)), right(std::move(right)) {}

    Value Evaluate(Scope& scope) const override
    {
        throw std::runtime_error("To implemente ASTFunctionCall");
    }
};

// New AST node
struct ASTBinaryComparison : ASTExpression
{
    std::string op; // ">", "<", ">=", "<=", "==", "!="
    std::unique_ptr<ASTExpression> left;
    std::unique_ptr<ASTExpression> right;

    ASTBinaryComparison(std::string op,
                        std::unique_ptr<ASTExpression> left,
                        std::unique_ptr<ASTExpression> right)
        : op(op), left(std::move(left)), right(std::move(right)) {}

    Value Evaluate(Scope& scope) const override
    {
        auto l = left->Evaluate(scope);
        auto r = right->Evaluate(scope);

        float lf = std::holds_alternative<int>(l) ? std::get<int>(l) : std::get<float>(l);
        float rf = std::holds_alternative<int>(r) ? std::get<int>(r) : std::get<float>(r);

        if (op == ">") return lf > rf ? 1 : 0;
        if (op == "<") return lf < rf ? 1 : 0;
        if (op == ">=") return lf >= rf ? 1 : 0;
        if (op == "<=") return lf <= rf ? 1 : 0;
        if (op == "==") return lf == rf ? 1 : 0;
        if (op == "!=") return lf != rf ? 1 : 0;

        throw std::runtime_error("Unknown comparison operator: " + op);
    }
};


struct ASTLetStatement : ASTNode
{
    std::string varName;
    std::unique_ptr<ASTExpression> value;
};

struct ASTStatement : ASTNode
{
    // Either Let or FunctionCall or FunctionDef or If/else
    std::unique_ptr<ASTNode> content;
};
struct ASTFunctionDef : ASTNode
{
    std::string name;
    std::vector<Parameter> parameters;
    std::vector<std::unique_ptr<ASTStatement>> body;
};

struct ASTIfStatement : ASTNode
{
    std::unique_ptr<ASTExpression> condition;
    std::vector<std::unique_ptr<ASTStatement>> thenBranch;
    std::vector<std::unique_ptr<ASTStatement>> elseBranch;
};


// PARSER

class PulseParser
{
public:
    PulseParser(const std::vector<Token> &tokens);

    // Entry point
    std::vector<std::unique_ptr<ASTStatement>> ParseScript();

private:
    const Token &Peek(int offset = 0) const;
    const Token &Next();
    bool Match(TokenType type);
    bool Consume(TokenType type, const char *error);

    std::unique_ptr<ASTStatement> ParseStatement();
    std::unique_ptr<ASTLetStatement> ParseLet();
    std::unique_ptr<ASTExpression> ParseExpression();
    std::unique_ptr<ASTFunctionCall> ParseFunctionCall(const std::string &name);
    std::unique_ptr<ASTFunctionDef> ParseFunctionDef();
    std::unique_ptr<ASTExpression> ParsePrimary();
    std::unique_ptr<ASTStatement> ParseIf();

    std::unique_ptr<ASTExpression> ParseTerm();
    std::unique_ptr<ASTExpression> ParseFactor();

private:
    std::vector<Token> tokens;
    size_t pos = 0;
};
